<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Generics and Semirings and Tilting at Windmills</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="David Walend's blog about scala, graphs, and coding">
    <link rel="canonical" href="http://dwalend.github.io/blog/2014/10/05/Semirings/">
<!--    <link rel="shortcut icon" href="/blogpublic/favicon.ico"> -->
<!--    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/blogpublic/apple-touch-icon-precomposed.png"> -->

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/main.css">

</head>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54450354-1', 'auto');
  ga('send', 'pageview');

</script>
    <body>

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="/blog/">Intuitive Counter: A Blog about Scala, Graphs, and Coding</a>

      <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
           viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
          
        
          
        
          <a class="page-link" href="/blog/projects/">Open Source Projects</a>
        
      </div>
    </nav>
  </div>

</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>Generics and Semirings and Tilting at Windmills</h1>
    <p class="meta">Oct 5, 2014</p>
  </header>

  <article class="post-content">
  <p>One of the coolest things you can do with graphs is find the shortest paths between nodes. One of the coolest things you can do with those algorithms is change what “shortest” means using semirings. It’s so cool it makes group theory useful. Scala’s type system is rich enough to handle all that without hurting people’s eyes, so I did it in <a href="https://github.com/dwalend/ScalaGraphMinimizer">ScalaGraphMinimizer</a>. </p>

<h2 id="type-families-and-semirings">Type Families and Semirings</h2>

<p>My biggest frustration with trying to define semirings in Java was that I had to carry everything around inside layered generic type specifications. There was no way to bound and encapsulate the layering, so the type specifications built up and became blinding eyesores. The advice I got was to not use Java’s type system that way. The only workable alternative was to cast as needed and hope it worked out at runtime. In contrast, Scala’s type system handles it gracefully. Scala lets me declare a namespace of types and use those declared types where needed. </p>

<p>Here’s SemiringSupport, which is primarily about holding on to a set of related types.</p>

<pre><code>trait SemiringSupport[L,Key] {

  type Label = L

  def semiring:Semiring

  def heapOrdering:HeapOrdering[Key]

  def heapKeyForLabel:Label =&gt; Key
</code></pre>

<p>SemiringSupport needs something to define the Labels the semiring operates on, a Semiring which brings the operators, and some bits to support heaps for Dijkstra’s algorithm. For the labels, I’m using a similar technique that I used for <a href="http://dwalend.github.io/blog/2014/09/10/graphs-in-scala/">the most general class of graphs</a>, but this time I have a type parameter, L, that helps the compiler do some work for me. </p>

<p>Here’s Semiring’s declaration, embedded inside the namespace. I think it is easy to map to the corresponding passage from Cormen’s <em>Algorithms</em>, “A general framework for solving path problems in directed graphs,” 26.4 in my 1989 copy. (Cormen seems to have dropped it from later editions, but I found an OK description in <a href="http://books.google.com/books?id=S-tXjl1hsUYC&amp;lpg=PA54&amp;dq=aho%20hopcroft%20ullman&amp;pg=PA336#v=snippet&amp;q=%22245.%20The%20algebraic%22&amp;f=false">Stoner’s <em>An Introduction to Data Structures and Algorithms</em></a>.)</p>

<pre><code>  trait Semiring {

    /** identity */
    def I:Label

    /** annihilator */
    def O:Label

    def inDomain(label:Label):Boolean

    def summary(fromThroughTo:Label,current:Label):Label

    def extend(fromThrough:Label,throughTo:Label):Label

    def relax(fromThrough:Label,throughTo:Label,current:Label):Label = {
      summary(extend(fromThrough,throughTo),current)
    }   
  }
}
</code></pre>

<p>With that in hand, I made a Semiring that counts nodes in a path. The Label is an Int – the number of nodes in the path. The heapKey is that Label. Existing edges in the graph have a Label of 1 because you’d have to cross one edge to get from the source node to the target node. The identity, I, is 0 because you’d cross zero nodes, and the annihilator, O, is Int.MaxValue because it is an absurdly large number. The summary operator picks the least of two Labels – the shortest of two paths. The extends method adds two Labels together – adding one path to another. I did have to monkey around inside the extend method to avoid wrapping Ints while slinging around Int.MaxValues. Other than that, the code is simple.</p>

<pre><code>object FewestNodes extends SemiringSupport[Int,Int] {

  def semiring = FewestNodesSemiring

  def heapOrdering = FewestNodesHeapOrdering

  def heapKeyForLabel = {label:Label =&gt; label}

  def convertEdgeToLabel[Node, EdgeLabel](start: Node, 
                                          end: Node, 
                                          label: EdgeLabel): FewestNodes.Label = 1

  object FewestNodesSemiring extends Semiring {

    def I = 0
    def O = Int.MaxValue

    def inDomain(label: Label): Boolean = {
      I &lt;= label &amp;&amp; label &lt; O
    }

    def summary(fromThroughToLabel:Label,
                currentLabel:Label):Label = {
      if(fromThroughToLabel &lt; currentLabel) {
        fromThroughToLabel
      }
      else currentLabel
    }

    def extend(fromThroughLabel:Label,throughToLabel:Label):Label = {
      if ((fromThroughLabel == O) || (throughToLabel == O)) O
      else {
        val result = fromThroughLabel + throughToLabel
        if(result &lt; 0) O //Wrapped
        else result
      }
    }
  }

  /**
   * A heap ordering that puts lower numbers on the top of the heap
   */
  object FewestNodesHeapOrdering extends HeapOrdering[Int] {
    //uninteresting HeapOrdering
  }

}
</code></pre>

<h2 id="algorithms-in-scala-can-look-like-algorithms-in-text-books-even-with-complex-types">Algorithms in Scala Can Look Like Algorithms In Text Books Even With Complex Types</h2>

<p>Even with the semiring mixed in, Dijkstra’s algorithm looks almost identical to the code from <a href="http://en.wikipedia.org/wiki/Dijkstra's_algorithm#Using_a_priority_queue">Wikipedia</a>:</p>

<pre><code>  def dijkstraSingleSource[Node,Label,Key](initialGraph:IndexedLabelDigraph[Node,Label],
                                           support:SemiringSupport[Label,Key])
                                          (source:initialGraph.InnerNodeType):Seq[(Node,Node,Label)] = {
    //Set up an array of Labels by node index
    val labels:ArrayBuffer[Label] = ArrayBuffer.fill(initialGraph.nodeCount)(support.semiring.O)

    //Set up the heap
    val heap:Heap[Key,initialGraph.InnerNodeType] = new FibonacciHeap(support.heapOrdering)

    val heapMembers:IndexedSeq[heap.HeapMember] = initialGraph.innerNodes.map(node =&gt; heap.insert(support.heapKeyForLabel(support.semiring.O),node))
    
    //Raise sourceInnerNode's to I
    labels(source.index) = support.semiring.I
    heapMembers(source.index).raiseKey(support.heapKeyForLabel(support.semiring.I))

    //While the heap is not empty
    while(!heap.isEmpty) {
      //take the top node
      val topNode = heap.takeTopValue()
      //For any node that is reachable from this node 
      for(successor &lt;- topNode.successors) {
        val heapKey = heapMembers(successor._2.index)
        //if the node has not yet been visited (because its key is still in the heap)
        if(heapKey.isInHeap) {
          //Relax to get a new label
          val label = relaxSource(initialGraph,labels,support.semiring)(source,topNode,successor)
          labels(successor._2.index) = label
          heapKey.raiseKey(support.heapKeyForLabel(label))
        }
      }
    }

    //put everything back together
    labels.zipWithIndex.map(x =&gt; (source.value,initialGraph.node(x._2),x._1)).filter(x =&gt; x._3 != support.semiring.O)
  }
</code></pre>

<h2 id="specific-types-semirings-in-this-case-make-the-algorithms-more-powerful-without-risking-correctness">Specific Types (Semirings in this Case) Make the Algorithms More Powerful Without Risking Correctness</h2>

<p>Creating new semirings, like this one for finding the most probable path, is easy and kinda fun:</p>

<pre><code>object MostProbable extends SemiringSupport[Double,Double] {

  def semiring = MostProbableSemiring

  def heapOrdering = MostProbableOrdering

  def heapKeyForLabel = {label:Label =&gt; label}

  def convertEdgeToLabel[Node, Label](start: Node, end: Node, label: Label): MostProbable.Label = semiring.I

  object MostProbableSemiring extends Semiring {

    def I = 1.0
    def O = 0.0

    def inDomain(label: Label): Boolean = {
      I &gt;= label &amp;&amp; label &gt; O
    }

    def summary(fromThroughToLabel:Label,
                currentLabel:Label):Label = {
      if(fromThroughToLabel &gt; currentLabel) {
        fromThroughToLabel
      }
      else currentLabel
    }

    def extend(fromThroughLabel:Label,throughToLabel:Label):Label = {
      if ((fromThroughLabel == O) || (throughToLabel == O)) O
      else {
        fromThroughLabel * throughToLabel
      }
    }
  }

  /**
   * A heap ordering that puts lower numbers on the top of the heap
   */
  object MostProbableOrdering extends HeapOrdering[Double] {
    //still not interesting 
  }
</code></pre>

<p>Best of all, Scala’s compiler is able to work out what the types are without my help</p>

<pre><code>val labelEdges = Dijkstra.allPairsShortestPaths(testGraph.edges,
                                                testGraph.nodesSeq,
                                                FewestNodes,
                                                FewestNodes.convertEdgeToLabel)
</code></pre>

<p>Compare that to this eye-burning call to Dijkstra’s algorithm in JDigraph:</p>

<pre><code>   Dijkstra&lt;LeastPathLabel,
          IndexedMutableSimpleDigraph&lt;TestBean&gt;,
          NextStepDigraph&lt;TestBean,LeastPathLabel,SimpleDigraph.SimpleEdge,IndexedMutableSimpleDigraph&lt;TestBean&gt;&gt;,
          LeastPathComparator,
          LeastPathSemiring&lt;TestBean,SimpleDigraph.SimpleEdge,IndexedMutableSimpleDigraph&lt;TestBean&gt;&gt;&gt; dijkstra = new Dijkstra&lt;LeastPathLabel,
                                                                                                                  IndexedMutableSimpleDigraph&lt;TestBean&gt;,
                                                                                                                  NextStepDigraph&lt;TestBean,LeastPathLabel,SimpleDigraph.SimpleEdge,IndexedMutableSimpleDigraph&lt;TestBean&gt;&gt;,
                                                                                                                  LeastPathComparator,
                                                                                                                  LeastPathSemiring&lt;TestBean,SimpleDigraph.SimpleEdge,IndexedMutableSimpleDigraph&lt;TestBean&gt;&gt;&gt;();
</code></pre>

<p>(Yes, Java’s new diamond operator might make this half the size. Too bad the code stopped compiling in JDK6.)</p>

<h2 id="maybe-that-lance-wasnt-the-right-tool-for-attacking-this-windmill">Maybe That Lance Wasn’t the Right Tool for Attacking this Windmill</h2>

<p>I’m very happy with how the code came out this early in the project. I’ve been able to make something both explainable and powerful, and extend it to solve for betweenness (which deserves its own blog article). It took eight weeks of a few hours after work when family and chores left me a little time, maybe just 25 hours total. The final code looks just like the algorithms in the book, not an example of some vile boundary case. </p>

<p>Download it and try it out. In sbt, it’s easy to type in a graph and try out different algorithms:</p>

<pre><code>libraryDependencies += "net.walend" %% "scalagraphminimizer" % "0.1.1"
</code></pre>

<p>Dave</p>

  </article>

</div>

      
<div id="disqus_thread"></div>
<script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'intuitivecounter'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">

    <h2 class="footer-heading">Intuitive Counter: A Blog about Scala, Graphs, and Coding</h2>

    <div class="footer-col-1 column">
      <ul>
        <li>Intuitive Counter: A Blog about Scala, Graphs, and Coding</li>
        <li><a href="mailto:david@walend.net">david@walend.net</a></li>
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        <li>
          <a href="https://github.com/dwalend">
            <span class="icon github">
              <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            <span class="username">dwalend</span>
          </a>
        </li>
        <li>
          <a href="https://twitter.com/dwalend">
            <span class="icon twitter">
              <svg version="1.1" class="twitter-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
              </svg>
            </span>
            <span class="username">dwalend</span>
          </a>
        </li>
      </ul>
    </div>

    <div class="footer-col-3 column">
      <p class="text">David Walend's blog about scala, graphs, and coding</p>
    </div>

  </div>

</footer>


    </body>
</html>