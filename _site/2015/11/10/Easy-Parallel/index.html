<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Parallel Disentangle</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="David Walend's blog about scala, graphs, and coding">
    <link rel="canonical" href="http://dwalend.github.io/blog/2015/11/10/Easy-Parallel/">
<!--    <link rel="shortcut icon" href="/blogpublic/favicon.ico"> -->
<!--    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/blogpublic/apple-touch-icon-precomposed.png"> -->

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/main.css">

</head>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54450354-1', 'auto');
  ga('send', 'pageview');

</script>
    <body>

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="/blog/">Intuitive Counter: A Blog about Scala, Graphs, and Coding</a>

      <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
           viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
          
        
          
        
          <a class="page-link" href="/blog/projects/">Open Source Projects</a>
        
      </div>
    </nav>
  </div>

</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>Parallel Disentangle</h1>
    <p class="meta">Nov 10, 2015</p>
  </header>

  <article class="post-content">
  <script type="text/javascript" src="../../../../disentangleParGraphs/js/d3.v3.js"></script>

<script type="text/javascript"src="../../../../disentangleParGraphs/js/queue.js"></script>

<script type="text/javascript"src="../../../../disentangleParGraphs/js/plot.js"></script>

<style type="text/css">

    path {
    stroke-width: 2;
    fill: none;
    }

    .axis path,
    .axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
    }

    .axis text {
    font-family: sans-serif;
    font-size: 10px;
    }
</style>

<p>TL/DR - I added parallel versions of Dijkstra&#39;s and Brandes&#39; algorithms to Disentangle. Writing the code was easy. Consider using  parallel versions of these algorithms when you&#39;ve got more than about 100 nodes in your graph and you have computational power to spare. Call them via</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">val simpleShortPathLabelsFromPar = Dijkstra.parAllPairsShortestPaths(edges)

val leastPathLabelsFromPar = Dijkstra.parAllPairsLeastPaths(edges,support,labelForEdge)

val shortestPathsAndBetweennessFromPar = Brandes.parAllLeastPathsAndBetweenness(edges)
</code></pre></div>
<p>Pull in the latest snapshot with</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">resolvers += &quot;Sonatype OSS Snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;

libraryDependencies += &quot;net.walend.disentangle&quot; %% &quot;graph&quot; % &quot;0.2.0-SNAPSHOT&quot;
</code></pre></div>
<h2>Scala&#39;s Parallel Collections</h2>

<p>Scala 2.9 provided <a href="http://docs.scala-lang.org/overviews/parallel-collections/overview.html">parallel versions of many of its standard collection classes</a>. Functional operations on these collections happen in parallel using a default compute pool. Dijkstra&#39;s and Brandes&#39; algorithms can be run in parallel for each node. Aleksandar Prokopec provided some encouraging advice - all I needed to do was run the outermost functional operations on a parallel collection of nodes to use all the cores available. </p>

<h2>Fifteen Minutes Later</h2>

<p>I needed about ten minutes for the first pass, and five for a second pass (<a href="TODO%20Brandes%20paper">Brandes&#39; has an extra wrinkle</a>) to get the algorithms running in parallel. Here&#39;s a code fragment from Dijkstra&#39;s algorithm:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">def parAllPairsLeastPaths[Node,EdgeLabel,Label,Key](edges: GenTraversable[(Node, Node, EdgeLabel)],
                                                    support: SemiringSupport[Label, Key],
                                                    labelForEdge: (Node, Node, EdgeLabel) =&gt; Label,
                                                    nodeOrder: GenSeq[Node] = ParSeq.empty):ParSeq[(Node, Node, Label)] = {
  val labelDigraph = createLabelDigraph(edges.par, support, labelForEdge, nodeOrder.par)

  //profiler blames both flatten and fold of IndexedSet as trouble
  labelDigraph.innerNodes.to[ParSeq].flatMap(source =&gt; dijkstraSingleSource(labelDigraph, support)(source))
}
</code></pre></div>
<p>Making the edges collection parallel speeds up translating to the internal directed graph representation. The bigger benefit, running dijkstraSingleSource in parallel, comes from making the nodes parallel. This code was so straight-forward that I wrote it while bouncing on the T on my way home from work.</p>

<h2>Results on an EC2 R3</h2>

<p>I spun up an AWS EC2 r3.8xlarge instance to benchmark on a quiet, modern multicore computer with a quarter-terabyte of ram. (A quick experiment on an AWS E2 c4.8xlarge showed that the system was ultimately memory-bound.) That part was easy. I spent most of my developer time tweaking graphs in D3.</p>

<div id="linearDijkstra" align="center"></div>

<script type="text/javascript">
plot3Results(false,"#linearDijkstra","../../../../disentangleParGraphs/results/dijkstra.csv","../../../../disentangleParGraphs/results/parDijkstra.csv","../../../../disentangleParGraphs/results/floydWarshall.csv")
</script>
 

<p>The right edge of this graph shows deviation from correct curves for Dijkstra&#39;s algorithm after about 4096 nodes. I think that&#39;s the garbage collector coming in to play. (Lower is faster.) The r3.8xlarge let me use 238 GB for the JVM, which ran Dijkstra&#39;s algorithm on graphs with 16384 nodes before crashing into an out-of-memory error. You&#39;ll notice the curve for the Floyd-Warshall algorithm arcing up quickly from the lower left. The Floyd-Warshall test didn&#39;t crash. As expected it was really slow so I stopped it once I had values for fewer nodes. I was expecting the parallel version of the algorithm to fill up memory faster than the serial version, but was pleasantly surprised that they failed on the same-sized graph. The parallel version found shortest paths for 16384 nodes in just over 15 minutes, a 6X speedup over the serial version. </p>

<div id="logDijkstra" align="center"></div>

<script type="text/javascript">
plot3Results(true,"#logDijkstra","../../../../disentangleParGraphs/results/dijkstra.csv","../../../../disentangleParGraphs/results/parDijkstra.csv","../../../../disentangleParGraphs/results/floydWarshall.csv")
</script>

<p>To examine what was happening in that lower left corner I plotted the results log/log. (A little lower is much faster.) As you can see, the crossover point where concurrency starts to pay off seems to be at about 90 nodes (on a quiet AWS r3.8xlarge with 32 cores and 244 GB ram - YMMV). The Floyd-Warshall algorithm was never better for graphs with 32 or more nodes.</p>

<p>I found similar results for Brandes algorithm.</p>

<div id="linearBrandes" align="center"></div>

<script type="text/javascript">
plot2Results(false,"#linearBrandes","../../../../disentangleParGraphs/results/brandes.csv","../../../../disentangleParGraphs/results/parBrandes.csv")
</script>

<div id="logBrandes" align="center"></div>

<script type="text/javascript">
plot2Results(true,"#logBrandes","../../../../disentangleParGraphs/results/brandes.csv","../../../../disentangleParGraphs/results/parBrandes.csv")
</script>

<p>You can see some inefficiency - maybe the JVM garbage collector - start to come into play after about 4096 nodes, but it was able to XXXXXXXXX h 16384 nodes on an EC2 r3.8xlarge, and find all shortest paths and betweenness for every node in just over 15 minutes, a 6X speed-up over non-parallel. Not bad for 15 minutes of effort with no regard for <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl&#39;s law</a>.</p>

<h2>Try it out</h2>

<p>Pull it into an sbt project via</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">resolvers += &quot;Sonatype OSS Snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;

libraryDependencies += &quot;net.walend.disentangle&quot; %% &quot;graph&quot; % &quot;0.2.0-SNAPSHOT&quot;
</code></pre></div>
<p>Or clone the project and play in the console</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">git clone https://github.com/dwalend/Disentangle.git
cd Disentangle
sbt console
</code></pre></div>
  </article>

</div>

      
<div id="disqus_thread"></div>
<script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'intuitivecounter'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">

    <h2 class="footer-heading">Intuitive Counter: A Blog about Scala, Graphs, and Coding</h2>

    <div class="footer-col-1 column">
      <ul>
        <li>Intuitive Counter: A Blog about Scala, Graphs, and Coding</li>
        <li><a href="mailto:david@walend.net">david@walend.net</a></li>
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        <li>
          <a href="https://github.com/dwalend">
            <span class="icon github">
              <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            <span class="username">dwalend</span>
          </a>
        </li>
        <li>
          <a href="https://twitter.com/dwalend">
            <span class="icon twitter">
              <svg version="1.1" class="twitter-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
              </svg>
            </span>
            <span class="username">dwalend</span>
          </a>
        </li>
      </ul>
    </div>

    <div class="footer-col-3 column">
      <p class="text">David Walend's blog about scala, graphs, and coding</p>
    </div>

  </div>

</footer>


    </body>
</html>