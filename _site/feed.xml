<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Intuitive Counter: A Blog about Scala, Graphs, and Coding</title>
    <description>David Walend&#39;s blog about scala, graphs, and coding</description>
    <link>http://dwalend.github.io/blog/</link>
    <atom:link href="http://dwalend.github.io/blog/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 01 Oct 2014 23:02:19 -0400</pubDate>
    <lastBuildDate>Wed, 01 Oct 2014 23:02:19 -0400</lastBuildDate>
    <generator>Jekyll v2.1.1</generator>
    
      <item>
        <title>Generics and Semirings and Tilting at Windmills</title>
        <description>&lt;p&gt;One of the coolest things you can do with graphs is find the shortest paths between nodes. One of the coolest things you can do with those algorithms is change what “shortest” means using semirings. It’s so cool it makes group theory useful. Scala’s type system is rich enough to handle all that without hurting people’s eyes, so I did it in &lt;a href=&quot;https://github.com/dwalend/ScalaGraphMinimizer&quot;&gt;ScalaGraphMinimizer&lt;/a&gt;. &lt;/p&gt;

&lt;h2 id=&quot;type-families-and-semirings&quot;&gt;Type Families and Semirings&lt;/h2&gt;

&lt;p&gt;My biggest frustration with trying to define semirings in Java was that I had to carry everything around inside layered generic type specifications. There was no way to bound and encapsulate the layering, so the type specifications built up and became blinding eyesores. The (best-available) advice I got was to not use Java’s type system that way. The only workable alternative was to cast as needed and hope it worked out at runtime. In contrast, Scala’s type system handles it gracefully. Scala lets me declare a namespace of types and use those declared types where needed. &lt;/p&gt;

&lt;p&gt;Here’s SemiringSupport, which is primarily about holding on to a set of related types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trait SemiringSupport[L,Key] {

  type Label = L

  def semiring:Semiring

  def heapOrdering:HeapOrdering[Key]

  def heapKeyForLabel:Label =&amp;gt; Key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SemiringSupport needs something to define the Labels the semiring operates on, a Semiring which brings the operators, and some bits to support heaps for Dijkstra’s algorithm. For the labels, I’m using a similar technique that I used for &lt;a href=&quot;http://dwalend.github.io/blog/2014/09/10/graphs-in-scala/&quot;&gt;the most general class of graphs&lt;/a&gt;, but this time I have a type parameter, L, that helps the compiler do some work for me. &lt;/p&gt;

&lt;p&gt;Here’s Semiring’s declaration, embedded inside the namespace. I think it is easy to map to the corresponding passage from Cormen’s &lt;em&gt;Algorithms&lt;/em&gt;, “A general framework for solving path problems in directed graphs,” 26.4 in my 1989 copy. (Cormen seems to have dropped it from later editions, but I found an OK description on line in &lt;a href=&quot;http://books.google.com/books?id=S-tXjl1hsUYC&amp;amp;lpg=PA54&amp;amp;dq=aho%20hopcroft%20ullman&amp;amp;pg=PA336#v=snippet&amp;amp;q=%22245.%20The%20algebraic%22&amp;amp;f=false&quot;&gt;Stoner’s &lt;em&gt;An Introduction to Data Structures and Algorithms&lt;/em&gt;&lt;/a&gt;.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  trait Semiring {

    /** identity */
    def I:Label

    /** annihilator */
    def O:Label

    def inDomain(label:Label):Boolean

    def summary(fromThroughTo:Label,current:Label):Label

    def extend(fromThrough:Label,throughTo:Label):Label

    def relax(fromThrough:Label,throughTo:Label,current:Label):Label = {
      summary(extend(fromThrough,throughTo),current)
    }   
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With that in hand, I made a Semiring that counts nodes in a path. The Label is an Int. The heapKey is that Label. Existing edges in the graph have a Label of 1. The identity, I, is 0, and the annihilator, O, is Int.MaxValue. The summary operator picks the least of two Labels. The extends method adds two Labels together. I did have to monkey around inside the extend method to avoid wrapping Ints. Other than that, the code is simple.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;object FewestNodes extends SemiringSupport[Int,Int] {

  def semiring = FewestNodesSemiring

  def heapOrdering = FewestNodesHeapOrdering

  def heapKeyForLabel = {label:Label =&amp;gt; label}

  def convertEdgeToLabel[Node, EdgeLabel](start: Node, 
                                          end: Node, 
                                          label: EdgeLabel): FewestNodes.Label = 1

  object FewestNodesSemiring extends Semiring {

    def I = 0
    def O = Int.MaxValue

    def inDomain(label: Label): Boolean = {
      I &amp;lt;= label &amp;amp;&amp;amp; label &amp;lt; O
    }

    def summary(fromThroughToLabel:Label,
                currentLabel:Label):Label = {
      if(fromThroughToLabel &amp;lt; currentLabel) {
        fromThroughToLabel
      }
      else currentLabel
    }

    def extend(fromThroughLabel:Label,throughToLabel:Label):Label = {
      if ((fromThroughLabel == O) || (throughToLabel == O)) O
      else {
        val result = fromThroughLabel + throughToLabel
        if(result &amp;lt; 0) O //Wrapped
        else result
      }
    }
  }

  /**
   * A heap ordering that puts lower numbers on the top of the heap
   */
  object FewestNodesHeapOrdering extends HeapOrdering[Int] {
    //uninteresting HeapOrdering
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;algorithms-in-scala-can-look-like-algorithms-in-text-books-even-with-complex-types&quot;&gt;Algorithms in Scala Can Look Like Algorithms In Text Books, Even With Complex Types&lt;/h2&gt;

&lt;p&gt;Even with the semiring mixed in, Dijkstra’s algorithm looks almost identical to the code from &lt;a href=&quot;http://en.wikipedia.org/wiki/Dijkstra&#39;s_algorithm#Using_a_priority_queue&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def dijkstraSingleSource[Node,Label,Key](initialGraph:IndexedLabelDigraph[Node,Label],
                                           support:SemiringSupport[Label,Key])
                                          (source:initialGraph.InnerNodeType):Seq[(Node,Node,Label)] = {
    //Set up an array of Labels by node index
    val labels:ArrayBuffer[Label] = ArrayBuffer.fill(initialGraph.nodeCount)(support.semiring.O)

    //Set up the heap
    val heap:Heap[Key,initialGraph.InnerNodeType] = new FibonacciHeap(support.heapOrdering)

    val heapMembers:IndexedSeq[heap.HeapMember] = initialGraph.innerNodes.map(node =&amp;gt; heap.insert(support.heapKeyForLabel(support.semiring.O),node))
    
    //Raise sourceInnerNode&#39;s to I
    labels(source.index) = support.semiring.I
    heapMembers(source.index).raiseKey(support.heapKeyForLabel(support.semiring.I))

    //While the heap is not empty
    while(!heap.isEmpty) {
      //take the top node
      val topNode = heap.takeTopValue()
      //For any node that is reachable from this node 
      for(successor &amp;lt;- topNode.successors) {
        val heapKey = heapMembers(successor._2.index)
        //if the node has not yet been visited (because its key is still in the heap)
        if(heapKey.isInHeap) {
          //Relax to get a new label
          val label = relaxSource(initialGraph,labels,support.semiring)(source,topNode,successor)
          labels(successor._2.index) = label
          heapKey.raiseKey(support.heapKeyForLabel(label))
        }
      }
    }

    //put everything back together
    labels.zipWithIndex.map(x =&amp;gt; (source.value,initialGraph.node(x._2),x._1)).filter(x =&amp;gt; x._3 != support.semiring.O)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;specific-types-semirings-in-this-case-make-the-algorithms-more-powerful-without-risking-correctness&quot;&gt;Specific Types (Semirings in this Case) Make the Algorithms More Powerful Without Risking Correctness&lt;/h2&gt;

&lt;p&gt;Creating new semirings, like this one for finding the most probable path, is easy and kinda fun:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;object MostProbable extends SemiringSupport[Double,Double] {

  def semiring = MostProbableSemiring

  def heapOrdering = MostProbableOrdering

  def heapKeyForLabel = {label:Label =&amp;gt; label}

  def convertEdgeToLabel[Node, Label](start: Node, end: Node, label: Label): MostProbable.Label = semiring.I

  object MostProbableSemiring extends Semiring {

    def I = 1.0
    def O = 0.0

    def inDomain(label: Label): Boolean = {
      I &amp;gt;= label &amp;amp;&amp;amp; label &amp;gt; O
    }

    def summary(fromThroughToLabel:Label,
                currentLabel:Label):Label = {
      if(fromThroughToLabel &amp;gt; currentLabel) {
        fromThroughToLabel
      }
      else currentLabel
    }

    def extend(fromThroughLabel:Label,throughToLabel:Label):Label = {
      if ((fromThroughLabel == O) || (throughToLabel == O)) O
      else {
        fromThroughLabel * throughToLabel
      }
    }
  }

  /**
   * A heap ordering that puts lower numbers on the top of the heap
   */
  object MostProbableOrdering extends HeapOrdering[Double] {
    //still not interesting 
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Best of all, Scala’s compiler is able to work out what the types are without my help&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val labelEdges = Dijkstra.allPairsShortestPaths(testGraph.edges,testGraph.nodesSeq,FewestNodes,FewestNodes.convertEdgeToLabel)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compare that to this eye-burning call to Dijkstra’s algorithm in JDigraph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Dijkstra&amp;lt;LeastPathLabel,
          IndexedMutableSimpleDigraph&amp;lt;TestBean&amp;gt;,
          NextStepDigraph&amp;lt;TestBean,LeastPathLabel,SimpleDigraph.SimpleEdge,IndexedMutableSimpleDigraph&amp;lt;TestBean&amp;gt;&amp;gt;,
          LeastPathComparator,
          LeastPathSemiring&amp;lt;TestBean,SimpleDigraph.SimpleEdge,IndexedMutableSimpleDigraph&amp;lt;TestBean&amp;gt;&amp;gt;&amp;gt; dijkstra = new Dijkstra&amp;lt;LeastPathLabel,
                                                                                                                  IndexedMutableSimpleDigraph&amp;lt;TestBean&amp;gt;,
                                                                                                                  NextStepDigraph&amp;lt;TestBean,LeastPathLabel,SimpleDigraph.SimpleEdge,IndexedMutableSimpleDigraph&amp;lt;TestBean&amp;gt;&amp;gt;,
                                                                                                                  LeastPathComparator,
                                                                                                                  LeastPathSemiring&amp;lt;TestBean,SimpleDigraph.SimpleEdge,IndexedMutableSimpleDigraph&amp;lt;TestBean&amp;gt;&amp;gt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Yes, Java’s new diamond operator might make this half the size. Too bad the code stopped compiling in JDK6.)&lt;/p&gt;

&lt;h2 id=&quot;maybe-that-lance-wasnt-the-right-tool-for-attacking-that-windmill&quot;&gt;Maybe That Lance Wasn’t the Right Tool for Attacking That Windmill&lt;/h2&gt;

&lt;p&gt;I’m very happy with how the code came out this early in the project. I’ve been able to make something both explainable and powerful, and extend it to solve for betweenness (which deserves its own blog article). It took eight weeks of a few hours after work when family and chores left me a little time, maybe just 25 hours total. The final code looks just like the algorithms in the book, not an example of some vile boundary case. &lt;/p&gt;

&lt;p&gt;Download it and try it out. In sbt, it’s easy to type in a graph and try out different algorithms:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;libraryDependencies += &quot;net.walend&quot; %% &quot;scalagraphminimizer&quot; % &quot;0.1.1&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dave&lt;/p&gt;
</description>
        <pubDate>Thu, 02 Oct 2014 00:00:00 -0400</pubDate>
        <link>http://dwalend.github.io/blog/2014/10/02/Semirings/</link>
        <guid isPermaLink="true">http://dwalend.github.io/blog/2014/10/02/Semirings/</guid>
        
        
      </item>
    
      <item>
        <title>Graphs, Now in Scala</title>
        <description>&lt;p&gt;Using my old JDigraph project, I did a lot of work with (unsurprisingly) directed graphs. I experimented with immutability before it was cool. I eventually hit the limit of Java’s type system and &lt;a href=&quot;https://weblogs.java.net/blog/dwalend/archive/2007/03/wild_winds_wres.html&quot;&gt;tried to punch through it.&lt;/a&gt; I’ve been able to get a lot further with hardly any grief in Scala. Scala’s type system has what I need and its collection library suits my taste. It just worked out of the box, was fun, and (I hope) is pretty easy to explain.&lt;/p&gt;

&lt;p&gt;In Scala also found I could put off defining the specifics of how a graph works until I was ready to define that kind of graph. Not having to predict the future perfectly from the outset is a huge win in object-oriented programming, and has really proven itself out over the last six months’ hacking. That’s something I could never do in Java.&lt;/p&gt;

&lt;p&gt;A graph has a set of nodes and a set of edges. The edges define some kind of relationship between the nodes, but there are a lot of different possible rules for how those relationships work. &lt;a href=&quot;http://en.wikipedia.org/wiki/Graph_(mathematics)#Distinction_in_terms_of_the_main_definition&quot;&gt;Wikipedia lists many of them&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;First I’ll show the easy parts: I’ll get to edges in a minute. A graph has a set of nodes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trait Graph[Node] {

  def nodes:GenSet[Node]

  def nodeCount:Int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I’ve only put in a parameter for the Node’s type.  &lt;/p&gt;

&lt;p&gt;I can get cleaner API if I use an internal representation of the nodes, similar to Java’s &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Map.Entry.html&quot;&gt;Map.Entry&lt;/a&gt;. This internal representation at least needs access to the node put into the graph.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /**
   * An internal representation of nodes within the graph
   */
  trait InnerNodeTrait {
    def value:Node
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here’s where things get interesting. I don’t know what the type of that internal node is going to be. However, for a given implementation of Graph all of those internal nodes will be InnerNodeType, and they are all at least InnerNodeTraits. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /**
   * The type of InnerNodeTrait for this digraph representation
   */
  type InnerNodeType &amp;lt;: InnerNodeTrait
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I’m not satisfied by the names InnerNodeTrait and InnerNodeType. Any suggestions for something better?&lt;/p&gt;

&lt;p&gt;I’ll want a way to return all the internal nodes, and get the internal node for an external node. I use the InnerNodeType in these definitions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /**
   * @return InnerNode representation of all of the nodes in the graph.
   */
  def innerNodes:Seq[InnerNodeType]

  /**
   * @param value a node that might be in this digraph
   * @return Some inner node if it exists in the digraph or None
   */
  def innerNode(value:Node):Option[InnerNodeType]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Defining edges is next. Someone using the API will pass in edges from the outside. Once the edges are in the Graph, it’s convenient to hand back an internal representation for edges. It will eventually carry around references to inner nodes (as InnerNodeTypes.) However, I don’t really know how the nodes will be related to each other yet. Therefore I declare both an OuterEdgeType and an InnerEdgeType. I don’t define anything about them except that they exist. They’ll have something to do with Node and InnerNodeType, but I can’t say what in a way that will be useful.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  type OuterEdgeType

  type InnerEdgeType
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any help with naming? “type OuterEdgeType” is half a step from “object MyFirstScalaCode” .&lt;/p&gt;

&lt;p&gt;I know I’ll need to have access to the edges, and I have just enough type information to do it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /**
   * @return A Traversable (usually something more specific) of the edges
   */
  def edges:GenTraversable[OuterEdgeType]

  /**
   * @return A Traversable (usually something more specific) of the edges as represented in the graph
   */
  def innerEdges:GenTraversable[InnerEdgeType]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I’ve managed to put off defining anything about edges except that edges exist, and they have an internal representation different from the external representation. The Graph class’ API has committed to exactly as much as Wikipedia describes. Sub-traits can define edges for specialized graphs: Undirected graphs with Set2[Node] for edges. Directed graphs can have (Node,Node) tuple edges. Hypergraphs can use Sets, and directed hypergraphs can use a pair of Sets. Bipartite graphs can have edges just of nodes of different classes – (Person,Job) for example. &lt;/p&gt;

&lt;p&gt;My favorite feature is that I don’t have to code up any of those variations until I’m ready to use them for something. I suspect (and hope) I can only find a place to use this construct (and the layered trait hierarchy that goes with it) once every few projects, but it should make a good capstone for a family of traits that builds from a very general concept. &lt;/p&gt;

&lt;p&gt;Here’s a labeled digraph example, where edges have labels:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trait LabelDigraph[Node,Label] extends Digraph[Node] {

  type OuterEdgeType = (Node,Node,Label)

  type InnerEdgeType = (InnerNodeType,InnerNodeType,Label)

  /**
   * @return the label to return when no edge exists. If Label is an Option, this will be None.
   */
  def noEdgeExistsLabel:Label

  /**
   * @return the Edge between start and end or noEdgeExistsValue if no edge connects start to end
   */
  def label(start:InnerNodeType,end:InnerNodeType):Label
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the first release, I settled on two implementations of LabelDigraph: MatrixLabelDigraph which supports the Floyd-Warshall algorithm, and AdjacencyLabelDigraph which supports both Dijkstra’s algorithm and Brandes’ betweenness algorithm. &lt;/p&gt;

&lt;p&gt;I tried to make constructing a graph very easy, by supplying companion objects with apply methods that have default arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def apply[Node,Label](edges:GenTraversable[(Node,Node,Label)] = Seq.empty,
                       nodes:GenSeq[Node] = Seq.empty,
                       noEdgeExistsValue:Label = null) = {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you can create a graph with a Vector of Tuple3s like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  val yourGraph = AdjacencyLabelDigraph(edges = Vector((&quot;A&quot;,&quot;B&quot;,&quot;ab&quot;),(&quot;B&quot;,&quot;C&quot;,&quot;bc&quot;),(&quot;C&quot;,&quot;A&quot;,&quot;ca&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/dwalend/ScalaGraphMinimizer&quot;&gt;It’s all in an open source project on GitHub&lt;/a&gt;. Download it and try it out. In sbt console, it’s easy to just doodle around with graphs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;libraryDependencies += &quot;net.walend&quot; %% &quot;scalagraphminimizer&quot; % &quot;0.1.0&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dave&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Sep 2014 00:00:00 -0400</pubDate>
        <link>http://dwalend.github.io/blog/2014/09/10/graphs-in-scala/</link>
        <guid isPermaLink="true">http://dwalend.github.io/blog/2014/09/10/graphs-in-scala/</guid>
        
        
      </item>
    
      <item>
        <title>Back From the Break</title>
        <description>&lt;p&gt;It’s been five years since my last blog post on &lt;a href=&quot;https://home.java.net/pub/au/95&quot;&gt;java.net&lt;/a&gt; – amazingly still there. &lt;/p&gt;

&lt;p&gt;The world changed a bit. Oracle bought Sun. I figured out how to start Matlab clusters on AWS for MathWorks. My first daughter was born. I taught myself some Scala. I left MathWorks for ActivateNetworks – a social network analysis start-up (with more favorable intellectual property rules). My second daughter was born and is just about to start talking. My first daughter started kindergarten. I started working almost exclusively in Scala. I returned to open source work a few months ago with the first release of &lt;a href=&quot;https://github.com/dwalend/ScalaGraphMinimizer&quot;&gt;ScalaGraphMinimizer&lt;/a&gt;, and I immediately started using it in my work to study how people communicate in their work. &lt;/p&gt;

&lt;p&gt;I miss the challenge of writing, so adding the blog back feels natural. I’ll mostly be describing what I find while I blunder through hobby projects. Many others are learning Scala, so hopefully what I have to say will be of some benefit to them (you?). The blog will be fairly technical, with lots of code examples. I’ll also be dropping in my opinion of what I think works well. I’ve been learning Scala largely in isolation, so I’ll occasionally post something alien-looking. Feel especially free to call that out in the comments.&lt;/p&gt;

&lt;p&gt;I’m also a proponent of explicit coding. I want the code to be so clear that people can look at it and either agree that it is correct or be able to easily spot places where the code’s behavior deviates from their expectations. Scala’s ability to blend object and functional programming fits that well. I can use objects to tell a story. Functional-style programming makes the whole story visible. &lt;/p&gt;

&lt;p&gt;Speakers at local MeetUps and conferences continue to surprise me with their praise of Scala. They talk about how writing Scala should be fun, and it usually is a blast. I’ve mostly enjoyed writing code over the years, but had never seen people talk openly about anything the way Scala’s proponents tell &lt;a href=&quot;https://www.youtube.com/watch?v=hzf3hTUKk8U&quot;&gt;how pleasant it is.&lt;/a&gt;. They even talk about &lt;a href=&quot;https://github.com/ktonga/reactive-turtle&quot;&gt;love and parenting&lt;/a&gt;. Further, the speakers at the Scala conferences and MeetUps are almost universally fit. Unlike so many in our profession, these people are jacked. They must have time to work out. I didn’t get it until I started doing almost all my work in Scala. I’ve gone from finishing just before deadlines to finishing with days or even whole weeks to spare. I use the time to polish my code, profile and speed it up, and to write extra tests. And then I get some exercise, horse around with my kids, work on open-source projects, and write a blog. &lt;/p&gt;
</description>
        <pubDate>Mon, 01 Sep 2014 00:00:00 -0400</pubDate>
        <link>http://dwalend.github.io/blog/2014/09/01/back-in/</link>
        <guid isPermaLink="true">http://dwalend.github.io/blog/2014/09/01/back-in/</guid>
        
        
      </item>
    
  </channel>
</rss>
